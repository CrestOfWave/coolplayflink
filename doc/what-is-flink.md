# 1. Architecture

flink是一个架构和分布式处理引擎，设计目的是有状态的处理有界流和无界流。flink可以运行与所有通用的集群管理器，以内存的速度进行计算并且支持任何规模部署。

下面，我们解释一下Flink架构的重要方面。

## 1.1 处理无界数据和有界数据

任何种类的数据都是以事件流的形式产生。信用卡交易，传感器测量，机器日志或网站或移动应用程序上的用户交互，所有这些数据都作为流生成。

数据可以作为有界流和无界流被处理。
1. 无界流意思很明显，只有开始没有结束。必须连续的处理无界流数据，也即是在事件注入之后立即要对其进行处理。不能等待数据到达了再去全部处理，因为数据是无界的并且永远不会结束数据注入。
处理无界流数据往往要求事件注入的时候有一定的顺序性，例如可以以事件产生的顺序注入，这样会使得处理结果完整。

2. 有界流，也即是有明确的开始和结束的定义。有界流可以等待数据全部注入完成了再开始处理。注入的顺序不是必须的了，因为对于一个静态的数据集，我们是可以对其进行排序的。有界流的处理也可以称为批处理。

![imgae](../pic/WhatIsFlink/有界流无界流图示.png)

flink擅长处理有界流和无界流数据集。精确的事件和状态控制可以使得flink可以运行任何针对无界流处理的应用。有界流数据通过为固定数据集特殊设计的算子和数据结构的处理，也表现出很好的性能。

## 1.2 可以部署与任何地方

Flink是分布式系统，为了处理应用程序需要计算资源。Flink可以整合所有通用的集群资源管理器，比如yarn，mesos，kubernetes，同时也可以单独运行。

当部署flink应用的时候，flink会根据应用程序配置的并行度自动识别需要的资源并且向资源管理器申请相应的资源。如过发生故障，Flink会通过申请新的容器来替换掉失败的容器。无论是提交app或者是控制app进行的通讯都是经过rest调用的形式进行的。这使得flink可以很轻松的整合到很多环境。


## 1.3 运行任意规模的应用

Flink可以运行任意规模的流式应用程序。应用会并发成数以千计的task，这些task在集群中分布式并行运行。因此，应用程序可以利用几乎无限量的CPU，主内存，磁盘和网络IO。
另外，flink可以保存非常大规模的应用状态。

其异步和增量检查点算法确保对处理延迟的影响最小，同时保证恰一次的状态一致性。

## 1.4 利用内存性能

有状态Flink应用程序针对本地状态访问进行了优化。任务状态始终保留在内存中，或者，如果状态大小超过可用内存，则保存在访问高效的磁盘上。

因此，任务通过访问本地（通常是内存中）状态来执行所有计算，从而产生非常低的处理延迟。 Flink通过定期和异步checkpoint本地状态到持久存储来保证在出现故障时的恰一次的状态一致性。

状态访问和存储的过程如下图：

![image](../pic/WhatIsFlink/local-state.png)

# 2. application

## 2.1 flink应用组成block

Apache Flink是一个用于对无界和有界数据流进行有状态计算的框架。 Flink提供在不同抽象级别的API，并为常见用例提供专用库。

在这里，我们介绍Flink易于使用和富有表现力的API和库。

可以用流处理框架构建和执行的应用程序的类型由框架控制流，状态和时间的成度来决定。下文中，我们会对流程序的组成部分进行介绍，并讲解flink处理他们的方法。

### 2.1.1 Streams

显然，流是流处理的根本。但是，流可以具有不同的特征，这些特征会影响流的处理方式。Flink是一个多功能的处理框架，可以处理任何类型的流。

   * 有界和无界流：流可以是无界的，也可以是有界的。Flink具有处理无界流的复杂功能，但也有专门的操作算子来有效地处理有界流。
   
   * 实时处理和离线处理: 所有的数据都是按照流的形式产生。有两种处理数据的方式，也即是实时处理和缓存下来在进行离线处理。
   
### 2.1.2 state

很多流都是由状态的，当然也有些流仅仅是单独的处理事件，这些流是无状态的。运行基本业务逻辑的任何应用程序都需要记住事件或中间结果，以便在以后的时间点访问它们，例如在收到下一个事件时或在特定持续时间之后。

![image](../pic/WhatIsFlink/function-state.png)

应用的状态是flink的一等公民。您可以通过观察Flink在状态处理环境中提供的所有功能来查看。

* Multiple State Primitives(多状态原语):
    
    Flink为不同的数据结构提供状态原语，例如atomic values, lists, or maps. 开发人员可以根据函数的访问模式选择最有效的状态原语。

* Pluggable State Backends(可插拔状态后端):
    
    应用程序状态由可插拔状态后端管理和checkpoint。 Flink具有不同的状态后端，可以在内存或RocksDB中存储状态，RocksDB是一种高效的嵌入式磁盘数据存储。 也可以插入自定义状态后端。

* Exactly-once state consistency(恰一次状态一致性): 
    
    flink的checkpoint和recovery算法保证了应用状态在失败的情况下的一致性。因此，故障是透明处理的，不会影响应用程序的正确性。

* Very Large State(非常大的状态):

     由于其异步和增量检查点算法，Flink能够维持几TB的应用程序状态。

* Scalable Applications(可扩展的应用程序)：

    Flink通过将状态重新分配给更多或更少的工作人员来支持有状态应用程序的扩展。


### 2.1.3 Time

事件是流程序的另一个重要组成部分。大多数事件流都具有固有的时间语义，因为每个事件都是在特定时间点生成的。此外，许多常见的流计算基于时间，例如窗口聚合，会话化(sessionization)，模式检测(pattern detection)和基于时间的join。

Flink提供了一组丰富的与时间相关的特征。

* 事件时间模式：
    
    使用事件时间语义处理流的应用程序根据事件的时间戳计算结果。因此，无论是否处理记录的或实时的事件，事件时间处理都允许准确和一致的结果。

* 支持watermark：
    
    Flink使用watermark来推断基于事件时间的应用中的时间。watermark也是一种灵活的机制，可以权衡结果的延迟和完整性。
    
* 延迟数据处理：

当使用watermark在事件时间模式下处理流时，可能会发生在所有相关事件到达之前已完成计算。这类事件被称为迟发事件。 Flink具有多种处理延迟事件的选项，例如通过侧输出重新路由它们以及更新以前完成的结果。

* 处理时间模式：

除了事件时间模式之外，Flink还支持处理时间语义，该处理时间语义执行由处理机器的系统时间触发计算。处理时间模式适用于具有严格的低延迟要求的某些应用，这些要求可以容忍近似结果。


# 3. operations

